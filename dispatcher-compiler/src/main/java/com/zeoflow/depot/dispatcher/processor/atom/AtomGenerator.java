/*
 * Copyright (C) 2017 depot
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.zeoflow.depot.dispatcher.processor.atom;

import androidx.annotation.NonNull;

import com.zeoflow.depot.TypeConverters;
import com.zeoflow.depot.dispatcher.processor.StringUtils;
import com.zeoflow.jx.file.AnnotationSpec;
import com.zeoflow.jx.file.ClassName;
import com.zeoflow.jx.file.FieldSpec;
import com.zeoflow.jx.file.MethodSpec;
import com.zeoflow.jx.file.TypeName;
import com.zeoflow.jx.file.TypeSpec;
import com.zeoflow.depot.dispatcher.processor.StringUtils;
import com.zeoflow.depot.Database;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;

import javax.lang.model.element.Modifier;
import javax.lang.model.util.Elements;

import static javax.lang.model.element.Modifier.ABSTRACT;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;

@SuppressWarnings({"WeakerAccess", "SpellCheckingInspection"})
public class AtomGenerator
{

    public static final String ATOM_CLASS_PREFIX = "_Database";
    private static final String PACKAGE_EXECUTORS = "java.util.concurrent.Executors";
    private static final String PACKAGE_DEPOT = "com.zeoflow.depot.Depot";
    private static final String PACKAGE_DEPOT_DATABASE_CALLBACK = "com.zeoflow.depot.DepotDatabase.Callback";
    private static final String PACKAGE_SUPPORT_SQLITE_DB = "com.zeoflow.sqlite.db.SupportSQLiteDatabase";
    private static final String FIELD_NAME_DATABASE_CALLBACK = "databaseCallback";
    public static final String FIELD_NAME_DATABASE_EXECUTOR = "databaseWriteExecutor";
    private final AtomAnnotatedClass annotatedClazz;
    private final Elements annotatedElementUtils;

    public AtomGenerator(
            @NonNull AtomAnnotatedClass annotatedClass,
            @NonNull Elements elementUtils
    )
    {
        this.annotatedClazz = annotatedClass;
        this.annotatedElementUtils = elementUtils;
    }

    public TypeSpec generate()
    {
        TypeSpec.Builder builder =
                TypeSpec.classBuilder(getClazzName())
                        .addJavadoc("Generated by AtomDatabaseInjector.\n")
                        .addModifiers(ABSTRACT)
                        .addModifiers(PUBLIC)
                        .superclass(ClassName.get(annotatedClazz.annotatedElement));
        builder.addAnnotation(generateClassAnnotation());
        if (annotatedClazz.converters.size() != 0) {
            builder.addAnnotation(generateConvertersAnnotation());
        }
        builder.addField(addNumberOfThreadsField());
        builder.addField(addDatabaseWriterExecutorField());
        builder.addField(addInstanceField());
        builder.addField(addDatabaseCallbackField());
        builder.addMethod(getDatabseMethod());
        builder.addMethods(generateAbstractDAOs());
        return builder.build();
    }

    private AnnotationSpec generateClassAnnotation()
    {
        List<ClassName> entities = new ArrayList<>();
        StringBuilder strFormat = new StringBuilder("{");
        for (ClassName className : annotatedClazz.entities)
        {
            strFormat.append("$T.class, ");
            entities.add(ClassName.get(className.getPackage(), className.className()));
        }
        strFormat.delete(strFormat.lastIndexOf(","), strFormat.lastIndexOf(",") + 2);
        strFormat.append("}");
        return AnnotationSpec.builder(Database.class)
                .addMember("entities", strFormat.toString(), entities.toArray())
                .addMember("version", String.valueOf(annotatedClazz.depotDispatcher.version()))
                .addMember("exportSchema", String.valueOf(annotatedClazz.depotDispatcher.exportSchema()))
                .build();
    }

    private AnnotationSpec generateConvertersAnnotation() {
        List<ClassName> entities = new ArrayList<>();
        StringBuilder strFormat = new StringBuilder("{");
        for (ClassName className : annotatedClazz.converters)
        {
            strFormat.append("$T.class, ");
            entities.add(ClassName.get(className.getPackage(), className.className()));
        }
        strFormat.delete(strFormat.lastIndexOf(","), strFormat.lastIndexOf(",") + 2);
        strFormat.append("}");
        return AnnotationSpec.builder(TypeConverters.class)
                .addMember("value", strFormat.toString(), entities.toArray())
                .build();
    }

    private FieldSpec addNumberOfThreadsField()
    {
        return FieldSpec.builder(
                Integer.class,
                "numberOfThreads",
                Modifier.PRIVATE,
                Modifier.STATIC,
                FINAL
        ).initializer(String.valueOf(annotatedClazz.depotDispatcher.numberThreads())).build();
    }

    private FieldSpec addDatabaseWriterExecutorField()
    {
        return FieldSpec.builder(
                ExecutorService.class,
                FIELD_NAME_DATABASE_EXECUTOR,
                Modifier.STATIC,
                PUBLIC,
                FINAL
        ).initializer(
                "$T.newFixedThreadPool(numberOfThreads)",
                getExecutorsPackageType()
        ).build();
    }

    private FieldSpec addInstanceField()
    {
        return FieldSpec.builder(
                getClassType(),
                "INSTANCE",
                Modifier.PRIVATE,
                Modifier.STATIC,
                Modifier.VOLATILE
        ).build();
    }

    private FieldSpec addDatabaseCallbackField()
    {
        FieldSpec.Builder databaseCallback = FieldSpec.builder(
                getDepotDatabaseCallbackPackageType(),
                FIELD_NAME_DATABASE_CALLBACK,
                Modifier.PRIVATE,
                Modifier.STATIC,
                FINAL
        );

        StringBuilder initializer = new StringBuilder();
        initializer.append("new DepotDatabase.Callback()");
        initializer.append("\n{");
        initializer.append("\n  @$T");
        initializer.append("\n  public void onCreate(@$T $T db)");
        initializer.append("\n  {");
        initializer.append("\n    super.onCreate(db);");
        initializer.append("\n    $N.execute(() ->");
        initializer.append("\n    {");
        for (ClassName className : annotatedClazz.dbBeans)
        {
            initializer.append("\n      ")
                    .append(className.className())
                    .append(" ")
                    .append(StringUtils.toLowerCamel(className.className()))
                    .append(" = INSTANCE.")
                    .append(StringUtils.toLowerCamel(className.className()))
                    .append("();");
        }
        initializer.append("\n    });");
        initializer.append("\n  }");
        initializer.append("\n}");
        databaseCallback.initializer(
                initializer.toString(),
                Override.class,
                NonNull.class,
                getSupportSQLiteDBPackageType(),
                FIELD_NAME_DATABASE_EXECUTOR
        );
        return databaseCallback.build();
    }

    private List<MethodSpec> generateAbstractDAOs()
    {
        List<MethodSpec> methods = new ArrayList<>();
        for (ClassName className : annotatedClazz.dbBeans)
        {
            methods.add(
                    MethodSpec.methodBuilder(StringUtils.toLowerCamel(className.className()))
                            .returns(ClassName.get(className.getPackage(), className.className()))
                            .addModifiers(Modifier.ABSTRACT, PUBLIC)
                            .build()
            );
        }
        return methods;
    }

    private MethodSpec getDatabseMethod()
    {
        MethodSpec.Builder databaseMethod = MethodSpec
                .methodBuilder("getDatabase")
                .returns(getClassType())
                .addModifiers(PUBLIC, Modifier.STATIC);
        databaseMethod.beginControlFlow("if (INSTANCE == null)");
        databaseMethod.beginControlFlow("synchronized ($N.class)", annotatedClazz.entityName + ATOM_CLASS_PREFIX);
        databaseMethod.beginControlFlow("if (INSTANCE == null)");
        databaseMethod.addStatement(
                "INSTANCE = $T.databaseBuilder($T.class, $S)" +
                        "\n.addCallback($N)" +
                        "\n.build()",
                getDepotCallbackPackageType(),
                getClassType(),
                getClazzName().toLowerCase().replaceAll("//.", "_"),
                FIELD_NAME_DATABASE_CALLBACK
        );
        databaseMethod.endControlFlow();
        databaseMethod.endControlFlow();
        databaseMethod.endControlFlow();
        databaseMethod.addStatement("return INSTANCE");
        return databaseMethod.build();
    }

    private ClassName getClassType()
    {
        return ClassName.get(annotatedClazz.packageName, getClazzName());
    }

    private String getClazzName()
    {
        return annotatedClazz.entityName + ATOM_CLASS_PREFIX;
    }

    private TypeName getExecutorsPackageType()
    {
        return TypeName.get(annotatedElementUtils.getTypeElement(PACKAGE_EXECUTORS).asType());
    }

    private TypeName getDepotDatabaseCallbackPackageType()
    {
        return TypeName.get(annotatedElementUtils.getTypeElement(PACKAGE_DEPOT_DATABASE_CALLBACK).asType());
    }

    private TypeName getDepotCallbackPackageType()
    {
        return TypeName.get(annotatedElementUtils.getTypeElement(PACKAGE_DEPOT).asType());
    }

    private TypeName getSupportSQLiteDBPackageType()
    {
        return TypeName.get(annotatedElementUtils.getTypeElement(PACKAGE_SUPPORT_SQLITE_DB).asType());
    }

}
